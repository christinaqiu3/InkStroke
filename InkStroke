bl_info = {
    "name": "InkStroke",
    "author": "Christina Qiu",
    "version": (1, 0),
    "blender": (3, 0, 0),
    "location": "View3D > Sidebar > InkStroke",
    "category": "3D View",
}

import bpy
from bpy.types import Operator, Panel
from bpy_extras import view3d_utils


# Material

def get_inkstroke_material():

    mat_name = "InkStroke_Material"

    # Reuse if already exists
    if mat_name in bpy.data.materials:
        return bpy.data.materials[mat_name]

    mat = bpy.data.materials.new(mat_name)
    mat.use_nodes = True

    nodes = mat.node_tree.nodes
    links = mat.node_tree.links

    nodes.clear()

    # Nodes
    output = nodes.new("ShaderNodeOutputMaterial")
    principled = nodes.new("ShaderNodeBsdfPrincipled")
    texcoord = nodes.new("ShaderNodeTexCoord")
    separate = nodes.new("ShaderNodeSeparateXYZ")
    noise = nodes.new("ShaderNodeTexNoise")
    colramp = nodes.new("ShaderNodeValToRGB")

    # Layout for cleanliness
    texcoord.location = (-800, 0)
    separate.location = (-600, 0)
    noise.location = (-400, 0)
    colramp.location = (-200, 0)
    principled.location = (0, 0)
    output.location = (200, 0)

    # Settings
    noise.inputs["Scale"].default_value = 20
    noise.inputs["Roughness"].default_value = 0.6

    colramp.color_ramp.elements[0].position = 0.3
    colramp.color_ramp.elements[1].position = 0.7

    principled.inputs["Base Color"].default_value = (0.02, 0.02, 0.02, 1)

    # Links
    links.new(texcoord.outputs["UV"], separate.inputs["Vector"])
    links.new(separate.outputs["X"], noise.inputs["Vector"])
    links.new(noise.outputs["Fac"], colramp.inputs["Fac"])
    links.new(colramp.outputs["Color"], principled.inputs["Base Color"])
    links.new(principled.outputs["BSDF"], output.inputs["Surface"])

    return mat


# -----------------------------
# Draw Operator
# -----------------------------
import mathutils

class INKSTROKE_OT_draw(Operator):
    bl_idname = "inkstroke.draw"
    bl_label = "InkStroke Draw"
    bl_options = {'REGISTER', 'UNDO'}

    drawing = False
    curve_obj = None
    spline = None

    drawing = False
    curve_obj = None
    spline = None
    last_point = None

    # Smoothing distance
    min_distance = 0.15

    def modal(self, context, event):
        if event.type == 'LEFTMOUSE':
            if event.value == 'PRESS':
                self.start_stroke(context, event)
                self.drawing = True

            elif event.value == 'RELEASE':
                self.drawing = False
                self.finish_stroke(context)
                return {'FINISHED'}

        elif event.type == 'MOUSEMOVE' and self.drawing:
            self.add_point(context, event)

        elif event.type in {'RIGHTMOUSE', 'ESC'}:
            return {'CANCELLED'}

        return {'RUNNING_MODAL'}

    def invoke(self, context, event):
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}

    def start_stroke(self, context, event):
        curve_data = bpy.data.curves.new("InkStroke", type='CURVE')
        curve_data.dimensions = '3D'
        curve_data.bevel_depth = 0.01
        curve_data.bevel_resolution = 3

        self.spline = curve_data.splines.new('BEZIER')

        self.curve_obj = bpy.data.objects.new("InkStrokeObj", curve_data)
        context.collection.objects.link(self.curve_obj)

        context.view_layer.objects.active = self.curve_obj
        self.curve_obj.select_set(True)

        location = self.mouse_to_3d(context, event)

        bp = self.spline.bezier_points[0]
        bp.co = location
        bp.handle_left_type = 'AUTO'
        bp.handle_right_type = 'AUTO'

        self.last_point = location

    def add_point(self, context, event):
        location = self.mouse_to_3d(context, event)

        # Distance-based smoothing
        if (location - self.last_point).length < self.min_distance:
            return

        self.spline.bezier_points.add(1)
        bp = self.spline.bezier_points[-1]
        bp.co = location
        bp.handle_left_type = 'AUTO'
        bp.handle_right_type = 'AUTO'

        self.last_point = location

    def finish_stroke(self, context):

        curve_data = self.curve_obj.data

        # Create first rectangular profile
        profile1 = bpy.data.curves.new("InkProfile1", type='CURVE')
        profile1.dimensions = '2D'
        profile1.fill_mode = 'BOTH'

        spline = profile1.splines.new('POLY')
        spline.points.add(3)

        width = 0.02
        height = 0.002

        spline.points[0].co = (-width, -height, 0, 1)
        spline.points[1].co = ( width, -height, 0, 1)
        spline.points[2].co = ( width,  height, 0, 1)
        spline.points[3].co = (-width,  height, 0, 1)

        profile_obj1 = bpy.data.objects.new("InkProfileObj1", profile1)
        context.collection.objects.link(profile_obj1)

        # Assign bevel object
        curve_data.bevel_mode = 'OBJECT'
        curve_data.bevel_object = profile_obj1

        # Duplicate and rotate 90 degrees for cross band
        profile_obj2 = profile_obj1.copy()
        profile_obj2.data = profile_obj1.data.copy()
        profile_obj2.rotation_euler[0] = 1.5708  # 90 degrees in radians
        context.collection.objects.link(profile_obj2)

        # Testing: Keep only one
        # curve_data.bevel_object = profile_obj2

        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.curve.select_all(action='SELECT')

    def mouse_to_3d(self, context, event):
        region = context.region
        rv3d = context.region_data
        coord = (event.mouse_region_x, event.mouse_region_y)

        return view3d_utils.region_2d_to_location_3d(
            region, rv3d, coord, rv3d.view_location
        )

import mathutils

class INKSTROKE_OT_generate_bands(Operator):
    bl_idname = "inkstroke.generate_bands"
    bl_label = "Generate Bands"

    width: bpy.props.FloatProperty(default=0.05, min=0.001)
    resolution: bpy.props.IntProperty(default=32, min=4)

    def execute(self, context):
        obj = context.active_object
        if not obj or obj.type != 'CURVE':
            self.report({'ERROR'}, "Select a curve first")
            return {'CANCELLED'}

        depsgraph = context.evaluated_depsgraph_get()
        eval_obj = obj.evaluated_get(depsgraph)
        mesh_from_curve = eval_obj.to_mesh()

        # Sample points from evaluated mesh
        points = [v.co.copy() for v in mesh_from_curve.vertices]

        if len(points) < 2:
            self.report({'ERROR'}, "Curve too short")
            return {'CANCELLED'}

        mesh = bpy.data.meshes.new("InkStrokeMesh")
        stroke_obj = bpy.data.objects.new("InkStrokeMeshObj", mesh)
        context.collection.objects.link(stroke_obj)

        verts = []
        faces = []
        uvs = []

        view_dir = context.region_data.view_rotation @ mathutils.Vector((0, 0, -1))

        total_length = sum((points[i] - points[i-1]).length for i in range(1, len(points)))
        accumulated = 0

        for i in range(len(points) - 1):
            p0 = points[i]
            p1 = points[i+1]

            tangent = (p1 - p0).normalized()
            n1 = tangent.cross(view_dir).normalized()
            n2 = tangent.cross(n1).normalized()

            accumulated += (p1 - p0).length
            u = accumulated / total_length

            for normal in (n1, n2):
                v0 = p0 + normal * self.width
                v1 = p0 - normal * self.width
                v2 = p1 - normal * self.width
                v3 = p1 + normal * self.width

                idx = len(verts)
                verts.extend([v0, v1, v2, v3])

                faces.append([idx, idx+1, idx+2, idx+3])

                uvs.extend([
                    (u, 1),
                    (u, 0),
                    (u, 0),
                    (u, 1),
                ])

        mesh.from_pydata(verts, [], faces)
        mesh.update()

        # UV Layer
        uv_layer = mesh.uv_layers.new(name="UVMap")
        for i, loop in enumerate(mesh.loops):
            uv_layer.data[i].uv = uvs[i]

        return {'FINISHED'}



# -----------------------------
# UI Panel
# -----------------------------
class INKSTROKE_PT_panel(Panel):
    bl_label = "InkStroke"
    bl_idname = "INKSTROKE_PT_panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'InkStroke'

    def draw(self, context):
        layout = self.layout
        layout.operator("inkstroke.draw", text="Draw", icon='GREASEPENCIL')
        layout.operator("inkstroke.generate_bands", text="Generate Bands")



# -----------------------------
# Registration
# -----------------------------
classes = (
    INKSTROKE_OT_draw,
    INKSTROKE_OT_generate_bands,
    INKSTROKE_PT_panel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

if __name__ == "__main__":
    register()
